// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint, unused_import
@ffi.DefaultAsset('package:chipmunk2d_physics_ffi/chipmunk2d_physics_ffi')
library;

import 'dart:ffi' as ffi;

/// Space management
@ffi.Native<ffi.Pointer<cpSpace> Function()>()
external ffi.Pointer<cpSpace> cp_space_new();

@ffi.Native<ffi.Void Function(ffi.Pointer<cpSpace>)>()
external void cp_space_free(
  ffi.Pointer<cpSpace> space,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpSpace>, cpFloat)>()
external void cp_space_step(
  ffi.Pointer<cpSpace> space,
  double dt,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpSpace>, cpVect)>()
external void cp_space_set_gravity(
  ffi.Pointer<cpSpace> space,
  cpVect gravity,
);

@ffi.Native<cpVect Function(ffi.Pointer<cpSpace>)>()
external cpVect cp_space_get_gravity(
  ffi.Pointer<cpSpace> space,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<cpSpace>)>()
external int cp_space_get_iterations(
  ffi.Pointer<cpSpace> space,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpSpace>, ffi.Int)>()
external void cp_space_set_iterations(
  ffi.Pointer<cpSpace> space,
  int iterations,
);

@ffi.Native<cpFloat Function(ffi.Pointer<cpSpace>)>()
external double cp_space_get_damping(
  ffi.Pointer<cpSpace> space,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpSpace>, cpFloat)>()
external void cp_space_set_damping(
  ffi.Pointer<cpSpace> space,
  double damping,
);

@ffi.Native<cpFloat Function(ffi.Pointer<cpSpace>)>()
external double cp_space_get_idle_speed_threshold(
  ffi.Pointer<cpSpace> space,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpSpace>, cpFloat)>()
external void cp_space_set_idle_speed_threshold(
  ffi.Pointer<cpSpace> space,
  double idleSpeedThreshold,
);

@ffi.Native<cpFloat Function(ffi.Pointer<cpSpace>)>()
external double cp_space_get_sleep_time_threshold(
  ffi.Pointer<cpSpace> space,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpSpace>, cpFloat)>()
external void cp_space_set_sleep_time_threshold(
  ffi.Pointer<cpSpace> space,
  double sleepTimeThreshold,
);

@ffi.Native<cpFloat Function(ffi.Pointer<cpSpace>)>()
external double cp_space_get_collision_slop(
  ffi.Pointer<cpSpace> space,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpSpace>, cpFloat)>()
external void cp_space_set_collision_slop(
  ffi.Pointer<cpSpace> space,
  double collisionSlop,
);

@ffi.Native<cpFloat Function(ffi.Pointer<cpSpace>)>()
external double cp_space_get_collision_bias(
  ffi.Pointer<cpSpace> space,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpSpace>, cpFloat)>()
external void cp_space_set_collision_bias(
  ffi.Pointer<cpSpace> space,
  double collisionBias,
);

@ffi.Native<ffi.UnsignedInt Function(ffi.Pointer<cpSpace>)>()
external int cp_space_get_collision_persistence(
  ffi.Pointer<cpSpace> space,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpSpace>, ffi.UnsignedInt)>()
external void cp_space_set_collision_persistence(
  ffi.Pointer<cpSpace> space,
  int collisionPersistence,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpSpace>)>()
external void cp_space_reindex_static(
  ffi.Pointer<cpSpace> space,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpSpace>, ffi.Pointer<cpShape>)>()
external void cp_space_reindex_shape(
  ffi.Pointer<cpSpace> space,
  ffi.Pointer<cpShape> shape,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpSpace>, ffi.Pointer<cpBody>)>()
external void cp_space_reindex_shapes_for_body(
  ffi.Pointer<cpSpace> space,
  ffi.Pointer<cpBody> body,
);

@ffi.Native<ffi.Pointer<cpBody> Function(ffi.Pointer<cpSpace>)>()
external ffi.Pointer<cpBody> cp_space_get_static_body(
  ffi.Pointer<cpSpace> space,
);

@ffi.Native<cpFloat Function(ffi.Pointer<cpSpace>)>()
external double cp_space_get_current_time_step(
  ffi.Pointer<cpSpace> space,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<cpSpace>)>()
external int cp_space_is_locked(
  ffi.Pointer<cpSpace> space,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<cpSpace>, ffi.Pointer<cpBody>)>()
external int cp_space_contains_body(
  ffi.Pointer<cpSpace> space,
  ffi.Pointer<cpBody> body,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<cpSpace>, ffi.Pointer<cpShape>)>()
external int cp_space_contains_shape(
  ffi.Pointer<cpSpace> space,
  ffi.Pointer<cpShape> shape,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<cpSpace>, ffi.Pointer<cpConstraint>)>()
external int cp_space_contains_constraint(
  ffi.Pointer<cpSpace> space,
  ffi.Pointer<cpConstraint> constraint,
);

/// Body management
@ffi.Native<ffi.Pointer<cpBody> Function(cpFloat, cpFloat)>()
external ffi.Pointer<cpBody> cp_body_new(
  double mass,
  double moment,
);

@ffi.Native<ffi.Pointer<cpBody> Function()>()
external ffi.Pointer<cpBody> cp_body_new_kinematic();

@ffi.Native<ffi.Pointer<cpBody> Function()>()
external ffi.Pointer<cpBody> cp_body_new_static();

@ffi.Native<ffi.Void Function(ffi.Pointer<cpBody>)>()
external void cp_body_free(
  ffi.Pointer<cpBody> body,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpBody>, cpVect)>()
external void cp_body_set_position(
  ffi.Pointer<cpBody> body,
  cpVect pos,
);

@ffi.Native<cpVect Function(ffi.Pointer<cpBody>)>()
external cpVect cp_body_get_position(
  ffi.Pointer<cpBody> body,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpBody>, cpVect)>()
external void cp_body_set_velocity(
  ffi.Pointer<cpBody> body,
  cpVect velocity,
);

@ffi.Native<cpVect Function(ffi.Pointer<cpBody>)>()
external cpVect cp_body_get_velocity(
  ffi.Pointer<cpBody> body,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpBody>, cpFloat)>()
external void cp_body_set_angle(
  ffi.Pointer<cpBody> body,
  double angle,
);

@ffi.Native<cpFloat Function(ffi.Pointer<cpBody>)>()
external double cp_body_get_angle(
  ffi.Pointer<cpBody> body,
);

@ffi.Native<cpFloat Function(ffi.Pointer<cpBody>)>()
external double cp_body_get_mass(
  ffi.Pointer<cpBody> body,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpBody>, cpFloat)>()
external void cp_body_set_mass(
  ffi.Pointer<cpBody> body,
  double mass,
);

@ffi.Native<cpFloat Function(ffi.Pointer<cpBody>)>()
external double cp_body_get_moment(
  ffi.Pointer<cpBody> body,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpBody>, cpFloat)>()
external void cp_body_set_moment(
  ffi.Pointer<cpBody> body,
  double moment,
);

@ffi.Native<cpVect Function(ffi.Pointer<cpBody>)>()
external cpVect cp_body_get_center_of_gravity(
  ffi.Pointer<cpBody> body,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpBody>, cpVect)>()
external void cp_body_set_center_of_gravity(
  ffi.Pointer<cpBody> body,
  cpVect cog,
);

@ffi.Native<cpVect Function(ffi.Pointer<cpBody>)>()
external cpVect cp_body_get_force(
  ffi.Pointer<cpBody> body,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpBody>, cpVect)>()
external void cp_body_set_force(
  ffi.Pointer<cpBody> body,
  cpVect force,
);

@ffi.Native<cpFloat Function(ffi.Pointer<cpBody>)>()
external double cp_body_get_angular_velocity(
  ffi.Pointer<cpBody> body,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpBody>, cpFloat)>()
external void cp_body_set_angular_velocity(
  ffi.Pointer<cpBody> body,
  double angularVelocity,
);

@ffi.Native<cpFloat Function(ffi.Pointer<cpBody>)>()
external double cp_body_get_torque(
  ffi.Pointer<cpBody> body,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpBody>, cpFloat)>()
external void cp_body_set_torque(
  ffi.Pointer<cpBody> body,
  double torque,
);

@ffi.Native<cpVect Function(ffi.Pointer<cpBody>)>()
external cpVect cp_body_get_rotation(
  ffi.Pointer<cpBody> body,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<cpBody>)>()
external int cp_body_get_type(
  ffi.Pointer<cpBody> body,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpBody>, ffi.Int)>()
external void cp_body_set_type(
  ffi.Pointer<cpBody> body,
  int type,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<cpBody>)>()
external int cp_body_is_sleeping(
  ffi.Pointer<cpBody> body,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpBody>)>()
external void cp_body_activate(
  ffi.Pointer<cpBody> body,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpBody>, ffi.Pointer<cpShape>)>()
external void cp_body_activate_static(
  ffi.Pointer<cpBody> body,
  ffi.Pointer<cpShape> filter,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpBody>)>()
external void cp_body_sleep(
  ffi.Pointer<cpBody> body,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpBody>, ffi.Pointer<cpBody>)>()
external void cp_body_sleep_with_group(
  ffi.Pointer<cpBody> body,
  ffi.Pointer<cpBody> group,
);

@ffi.Native<cpVect Function(ffi.Pointer<cpBody>, cpVect)>()
external cpVect cp_body_local_to_world(
  ffi.Pointer<cpBody> body,
  cpVect point,
);

@ffi.Native<cpVect Function(ffi.Pointer<cpBody>, cpVect)>()
external cpVect cp_body_world_to_local(
  ffi.Pointer<cpBody> body,
  cpVect point,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpBody>, cpVect, cpVect)>()
external void cp_body_apply_force_at_world_point(
  ffi.Pointer<cpBody> body,
  cpVect force,
  cpVect point,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpBody>, cpVect, cpVect)>()
external void cp_body_apply_force_at_local_point(
  ffi.Pointer<cpBody> body,
  cpVect force,
  cpVect point,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpBody>, cpVect, cpVect)>()
external void cp_body_apply_impulse_at_world_point(
  ffi.Pointer<cpBody> body,
  cpVect impulse,
  cpVect point,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpBody>, cpVect, cpVect)>()
external void cp_body_apply_impulse_at_local_point(
  ffi.Pointer<cpBody> body,
  cpVect impulse,
  cpVect point,
);

@ffi.Native<cpVect Function(ffi.Pointer<cpBody>, cpVect)>()
external cpVect cp_body_get_velocity_at_world_point(
  ffi.Pointer<cpBody> body,
  cpVect point,
);

@ffi.Native<cpVect Function(ffi.Pointer<cpBody>, cpVect)>()
external cpVect cp_body_get_velocity_at_local_point(
  ffi.Pointer<cpBody> body,
  cpVect point,
);

@ffi.Native<cpFloat Function(ffi.Pointer<cpBody>)>()
external double cp_body_kinetic_energy(
  ffi.Pointer<cpBody> body,
);

@ffi.Native<ffi.Pointer<cpSpace> Function(ffi.Pointer<cpBody>)>()
external ffi.Pointer<cpSpace> cp_body_get_space(
  ffi.Pointer<cpBody> body,
);

/// Shape management
@ffi.Native<ffi.Pointer<cpShape> Function(ffi.Pointer<cpBody>, cpFloat, cpVect)>()
external ffi.Pointer<cpShape> cp_circle_shape_new(
  ffi.Pointer<cpBody> body,
  double radius,
  cpVect offset,
);

@ffi.Native<ffi.Pointer<cpShape> Function(ffi.Pointer<cpBody>, cpFloat, cpFloat, cpFloat)>()
external ffi.Pointer<cpShape> cp_box_shape_new(
  ffi.Pointer<cpBody> body,
  double width,
  double height,
  double radius,
);

@ffi.Native<ffi.Pointer<cpShape> Function(ffi.Pointer<cpBody>, cpVect, cpVect, cpFloat)>()
external ffi.Pointer<cpShape> cp_segment_shape_new(
  ffi.Pointer<cpBody> body,
  cpVect a,
  cpVect b,
  double radius,
);

@ffi.Native<ffi.Pointer<cpShape> Function(ffi.Pointer<cpBody>, ffi.Int, ffi.Pointer<cpVect>, cpTransform, cpFloat)>()
external ffi.Pointer<cpShape> cp_poly_shape_new(
  ffi.Pointer<cpBody> body,
  int count,
  ffi.Pointer<cpVect> verts,
  cpTransform transform,
  double radius,
);

@ffi.Native<ffi.Pointer<cpShape> Function(ffi.Pointer<cpBody>, ffi.Int, ffi.Pointer<cpVect>, cpFloat)>()
external ffi.Pointer<cpShape> cp_poly_shape_new_raw(
  ffi.Pointer<cpBody> body,
  int count,
  ffi.Pointer<cpVect> verts,
  double radius,
);

@ffi.Native<ffi.Pointer<cpShape> Function(ffi.Pointer<cpBody>, cpBB, cpFloat)>()
external ffi.Pointer<cpShape> cp_box_shape_new2(
  ffi.Pointer<cpBody> body,
  cpBB box,
  double radius,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpShape>)>()
external void cp_shape_free(
  ffi.Pointer<cpShape> shape,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpShape>, cpFloat)>()
external void cp_shape_set_friction(
  ffi.Pointer<cpShape> shape,
  double friction,
);

@ffi.Native<cpFloat Function(ffi.Pointer<cpShape>)>()
external double cp_shape_get_friction(
  ffi.Pointer<cpShape> shape,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpShape>, cpFloat)>()
external void cp_shape_set_elasticity(
  ffi.Pointer<cpShape> shape,
  double elasticity,
);

@ffi.Native<cpFloat Function(ffi.Pointer<cpShape>)>()
external double cp_shape_get_elasticity(
  ffi.Pointer<cpShape> shape,
);

@ffi.Native<cpShapeFilter Function(ffi.Pointer<cpShape>)>()
external cpShapeFilter cp_shape_get_filter(
  ffi.Pointer<cpShape> shape,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpShape>, cpShapeFilter)>()
external void cp_shape_set_filter(
  ffi.Pointer<cpShape> shape,
  cpShapeFilter filter,
);

@ffi.Native<cpShapeFilter Function(cpGroup, cpBitmask, cpBitmask)>()
external cpShapeFilter cp_shape_filter_new(
  int group,
  int categories,
  int mask,
);

@ffi.Native<cpFloat Function(ffi.Pointer<cpShape>)>()
external double cp_shape_get_mass(
  ffi.Pointer<cpShape> shape,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpShape>, cpFloat)>()
external void cp_shape_set_mass(
  ffi.Pointer<cpShape> shape,
  double mass,
);

@ffi.Native<cpFloat Function(ffi.Pointer<cpShape>)>()
external double cp_shape_get_density(
  ffi.Pointer<cpShape> shape,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpShape>, cpFloat)>()
external void cp_shape_set_density(
  ffi.Pointer<cpShape> shape,
  double density,
);

@ffi.Native<cpFloat Function(ffi.Pointer<cpShape>)>()
external double cp_shape_get_moment(
  ffi.Pointer<cpShape> shape,
);

@ffi.Native<cpFloat Function(ffi.Pointer<cpShape>)>()
external double cp_shape_get_area(
  ffi.Pointer<cpShape> shape,
);

@ffi.Native<cpVect Function(ffi.Pointer<cpShape>)>()
external cpVect cp_shape_get_center_of_gravity(
  ffi.Pointer<cpShape> shape,
);

@ffi.Native<cpBB Function(ffi.Pointer<cpShape>)>()
external cpBB cp_shape_get_bb(
  ffi.Pointer<cpShape> shape,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<cpShape>)>()
external int cp_shape_get_sensor(
  ffi.Pointer<cpShape> shape,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpShape>, ffi.Int)>()
external void cp_shape_set_sensor(
  ffi.Pointer<cpShape> shape,
  int sensor,
);

@ffi.Native<cpVect Function(ffi.Pointer<cpShape>)>()
external cpVect cp_shape_get_surface_velocity(
  ffi.Pointer<cpShape> shape,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpShape>, cpVect)>()
external void cp_shape_set_surface_velocity(
  ffi.Pointer<cpShape> shape,
  cpVect surfaceVelocity,
);

@ffi.Native<ffi.UintPtr Function(ffi.Pointer<cpShape>)>()
external int cp_shape_get_collision_type(
  ffi.Pointer<cpShape> shape,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpShape>, ffi.UintPtr)>()
external void cp_shape_set_collision_type(
  ffi.Pointer<cpShape> shape,
  int collisionType,
);

@ffi.Native<ffi.Pointer<cpBody> Function(ffi.Pointer<cpShape>)>()
external ffi.Pointer<cpBody> cp_shape_get_body(
  ffi.Pointer<cpShape> shape,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpShape>, ffi.Pointer<cpBody>)>()
external void cp_shape_set_body(
  ffi.Pointer<cpShape> shape,
  ffi.Pointer<cpBody> body,
);

@ffi.Native<ffi.Pointer<cpSpace> Function(ffi.Pointer<cpShape>)>()
external ffi.Pointer<cpSpace> cp_shape_get_space(
  ffi.Pointer<cpShape> shape,
);

@ffi.Native<cpFloat Function(ffi.Pointer<cpShape>, cpVect, ffi.Pointer<cpPointQueryInfo>)>()
external double cp_shape_point_query(
  ffi.Pointer<cpShape> shape,
  cpVect p,
  ffi.Pointer<cpPointQueryInfo> out,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<cpShape>, cpVect, cpVect, cpFloat, ffi.Pointer<cpSegmentQueryInfo>)>()
external int cp_shape_segment_query(
  ffi.Pointer<cpShape> shape,
  cpVect a,
  cpVect b,
  double radius,
  ffi.Pointer<cpSegmentQueryInfo> info,
);

@ffi.Native<cpContactPointSet Function(ffi.Pointer<cpShape>, ffi.Pointer<cpShape>)>()
external cpContactPointSet cp_shapes_collide(
  ffi.Pointer<cpShape> a,
  ffi.Pointer<cpShape> b,
);

/// Circle shape specific
@ffi.Native<cpVect Function(ffi.Pointer<cpShape>)>()
external cpVect cp_circle_shape_get_offset(
  ffi.Pointer<cpShape> shape,
);

@ffi.Native<cpFloat Function(ffi.Pointer<cpShape>)>()
external double cp_circle_shape_get_radius(
  ffi.Pointer<cpShape> shape,
);

/// Segment shape specific
@ffi.Native<cpVect Function(ffi.Pointer<cpShape>)>()
external cpVect cp_segment_shape_get_a(
  ffi.Pointer<cpShape> shape,
);

@ffi.Native<cpVect Function(ffi.Pointer<cpShape>)>()
external cpVect cp_segment_shape_get_b(
  ffi.Pointer<cpShape> shape,
);

@ffi.Native<cpVect Function(ffi.Pointer<cpShape>)>()
external cpVect cp_segment_shape_get_normal(
  ffi.Pointer<cpShape> shape,
);

@ffi.Native<cpFloat Function(ffi.Pointer<cpShape>)>()
external double cp_segment_shape_get_radius(
  ffi.Pointer<cpShape> shape,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpShape>, cpVect, cpVect)>()
external void cp_segment_shape_set_neighbors(
  ffi.Pointer<cpShape> shape,
  cpVect prev,
  cpVect next,
);

/// Poly shape specific
@ffi.Native<ffi.Int Function(ffi.Pointer<cpShape>)>()
external int cp_poly_shape_get_count(
  ffi.Pointer<cpShape> shape,
);

@ffi.Native<cpVect Function(ffi.Pointer<cpShape>, ffi.Int)>()
external cpVect cp_poly_shape_get_vert(
  ffi.Pointer<cpShape> shape,
  int index,
);

@ffi.Native<cpFloat Function(ffi.Pointer<cpShape>)>()
external double cp_poly_shape_get_radius(
  ffi.Pointer<cpShape> shape,
);

/// Space-Body-Shape relationships
@ffi.Native<ffi.Void Function(ffi.Pointer<cpSpace>, ffi.Pointer<cpBody>)>()
external void cp_space_add_body(
  ffi.Pointer<cpSpace> space,
  ffi.Pointer<cpBody> body,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpSpace>, ffi.Pointer<cpBody>)>()
external void cp_space_remove_body(
  ffi.Pointer<cpSpace> space,
  ffi.Pointer<cpBody> body,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpSpace>, ffi.Pointer<cpShape>)>()
external void cp_space_add_shape(
  ffi.Pointer<cpSpace> space,
  ffi.Pointer<cpShape> shape,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpSpace>, ffi.Pointer<cpShape>)>()
external void cp_space_remove_shape(
  ffi.Pointer<cpSpace> space,
  ffi.Pointer<cpShape> shape,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpSpace>, ffi.Pointer<cpConstraint>)>()
external void cp_space_add_constraint(
  ffi.Pointer<cpSpace> space,
  ffi.Pointer<cpConstraint> constraint,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpSpace>, ffi.Pointer<cpConstraint>)>()
external void cp_space_remove_constraint(
  ffi.Pointer<cpSpace> space,
  ffi.Pointer<cpConstraint> constraint,
);

/// Vector utilities
@ffi.Native<cpVect Function(cpFloat, cpFloat)>()
external cpVect cp_vect_new(
  double x,
  double y,
);

@ffi.Native<cpFloat Function(cpVect)>()
external double cp_vect_get_x(
  cpVect v,
);

@ffi.Native<cpFloat Function(cpVect)>()
external double cp_vect_get_y(
  cpVect v,
);

/// Collision detection and spatial queries
@ffi.Native<
  ffi.Pointer<cpShape> Function(ffi.Pointer<cpSpace>, cpVect, cpFloat, cpShapeFilter, ffi.Pointer<cpPointQueryInfo>)
>()
external ffi.Pointer<cpShape> cp_space_point_query_nearest(
  ffi.Pointer<cpSpace> space,
  cpVect point,
  double maxDistance,
  cpShapeFilter filter,
  ffi.Pointer<cpPointQueryInfo> out,
);

@ffi.Native<
  ffi.Pointer<cpShape> Function(
    ffi.Pointer<cpSpace>,
    cpVect,
    cpVect,
    cpFloat,
    cpShapeFilter,
    ffi.Pointer<cpSegmentQueryInfo>,
  )
>()
external ffi.Pointer<cpShape> cp_space_segment_query_first(
  ffi.Pointer<cpSpace> space,
  cpVect start,
  cpVect end,
  double radius,
  cpShapeFilter filter,
  ffi.Pointer<cpSegmentQueryInfo> out,
);

@ffi.Native<
  ffi.Int Function(ffi.Pointer<cpSpace>, ffi.Pointer<cpShape>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)
>()
external int cp_space_shape_query(
  ffi.Pointer<cpSpace> space,
  ffi.Pointer<cpShape> shape,
  ffi.Pointer<ffi.Void> func,
  ffi.Pointer<ffi.Void> data,
);

/// Constraint management
@ffi.Native<ffi.Void Function(ffi.Pointer<cpConstraint>)>()
external void cp_constraint_free(
  ffi.Pointer<cpConstraint> constraint,
);

@ffi.Native<ffi.Pointer<cpSpace> Function(ffi.Pointer<cpConstraint>)>()
external ffi.Pointer<cpSpace> cp_constraint_get_space(
  ffi.Pointer<cpConstraint> constraint,
);

@ffi.Native<ffi.Pointer<cpBody> Function(ffi.Pointer<cpConstraint>)>()
external ffi.Pointer<cpBody> cp_constraint_get_body_a(
  ffi.Pointer<cpConstraint> constraint,
);

@ffi.Native<ffi.Pointer<cpBody> Function(ffi.Pointer<cpConstraint>)>()
external ffi.Pointer<cpBody> cp_constraint_get_body_b(
  ffi.Pointer<cpConstraint> constraint,
);

@ffi.Native<cpFloat Function(ffi.Pointer<cpConstraint>)>()
external double cp_constraint_get_max_force(
  ffi.Pointer<cpConstraint> constraint,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpConstraint>, cpFloat)>()
external void cp_constraint_set_max_force(
  ffi.Pointer<cpConstraint> constraint,
  double maxForce,
);

@ffi.Native<cpFloat Function(ffi.Pointer<cpConstraint>)>()
external double cp_constraint_get_error_bias(
  ffi.Pointer<cpConstraint> constraint,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpConstraint>, cpFloat)>()
external void cp_constraint_set_error_bias(
  ffi.Pointer<cpConstraint> constraint,
  double errorBias,
);

@ffi.Native<cpFloat Function(ffi.Pointer<cpConstraint>)>()
external double cp_constraint_get_max_bias(
  ffi.Pointer<cpConstraint> constraint,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpConstraint>, cpFloat)>()
external void cp_constraint_set_max_bias(
  ffi.Pointer<cpConstraint> constraint,
  double maxBias,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<cpConstraint>)>()
external int cp_constraint_get_collide_bodies(
  ffi.Pointer<cpConstraint> constraint,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpConstraint>, ffi.Int)>()
external void cp_constraint_set_collide_bodies(
  ffi.Pointer<cpConstraint> constraint,
  int collideBodies,
);

@ffi.Native<cpFloat Function(ffi.Pointer<cpConstraint>)>()
external double cp_constraint_get_impulse(
  ffi.Pointer<cpConstraint> constraint,
);

/// Pin joint
@ffi.Native<ffi.Pointer<cpConstraint> Function(ffi.Pointer<cpBody>, ffi.Pointer<cpBody>, cpVect, cpVect)>()
external ffi.Pointer<cpConstraint> cp_pin_joint_new(
  ffi.Pointer<cpBody> a,
  ffi.Pointer<cpBody> b,
  cpVect anchorA,
  cpVect anchorB,
);

@ffi.Native<cpVect Function(ffi.Pointer<cpConstraint>)>()
external cpVect cp_pin_joint_get_anchor_a(
  ffi.Pointer<cpConstraint> constraint,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpConstraint>, cpVect)>()
external void cp_pin_joint_set_anchor_a(
  ffi.Pointer<cpConstraint> constraint,
  cpVect anchorA,
);

@ffi.Native<cpVect Function(ffi.Pointer<cpConstraint>)>()
external cpVect cp_pin_joint_get_anchor_b(
  ffi.Pointer<cpConstraint> constraint,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpConstraint>, cpVect)>()
external void cp_pin_joint_set_anchor_b(
  ffi.Pointer<cpConstraint> constraint,
  cpVect anchorB,
);

@ffi.Native<cpFloat Function(ffi.Pointer<cpConstraint>)>()
external double cp_pin_joint_get_dist(
  ffi.Pointer<cpConstraint> constraint,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpConstraint>, cpFloat)>()
external void cp_pin_joint_set_dist(
  ffi.Pointer<cpConstraint> constraint,
  double dist,
);

/// Slide joint
@ffi.Native<
  ffi.Pointer<cpConstraint> Function(ffi.Pointer<cpBody>, ffi.Pointer<cpBody>, cpVect, cpVect, cpFloat, cpFloat)
>()
external ffi.Pointer<cpConstraint> cp_slide_joint_new(
  ffi.Pointer<cpBody> a,
  ffi.Pointer<cpBody> b,
  cpVect anchorA,
  cpVect anchorB,
  double min,
  double max,
);

@ffi.Native<cpVect Function(ffi.Pointer<cpConstraint>)>()
external cpVect cp_slide_joint_get_anchor_a(
  ffi.Pointer<cpConstraint> constraint,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpConstraint>, cpVect)>()
external void cp_slide_joint_set_anchor_a(
  ffi.Pointer<cpConstraint> constraint,
  cpVect anchorA,
);

@ffi.Native<cpVect Function(ffi.Pointer<cpConstraint>)>()
external cpVect cp_slide_joint_get_anchor_b(
  ffi.Pointer<cpConstraint> constraint,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpConstraint>, cpVect)>()
external void cp_slide_joint_set_anchor_b(
  ffi.Pointer<cpConstraint> constraint,
  cpVect anchorB,
);

@ffi.Native<cpFloat Function(ffi.Pointer<cpConstraint>)>()
external double cp_slide_joint_get_min(
  ffi.Pointer<cpConstraint> constraint,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpConstraint>, cpFloat)>()
external void cp_slide_joint_set_min(
  ffi.Pointer<cpConstraint> constraint,
  double min,
);

@ffi.Native<cpFloat Function(ffi.Pointer<cpConstraint>)>()
external double cp_slide_joint_get_max(
  ffi.Pointer<cpConstraint> constraint,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpConstraint>, cpFloat)>()
external void cp_slide_joint_set_max(
  ffi.Pointer<cpConstraint> constraint,
  double max,
);

/// Pivot joint
@ffi.Native<ffi.Pointer<cpConstraint> Function(ffi.Pointer<cpBody>, ffi.Pointer<cpBody>, cpVect)>()
external ffi.Pointer<cpConstraint> cp_pivot_joint_new(
  ffi.Pointer<cpBody> a,
  ffi.Pointer<cpBody> b,
  cpVect pivot,
);

@ffi.Native<ffi.Pointer<cpConstraint> Function(ffi.Pointer<cpBody>, ffi.Pointer<cpBody>, cpVect, cpVect)>()
external ffi.Pointer<cpConstraint> cp_pivot_joint_new2(
  ffi.Pointer<cpBody> a,
  ffi.Pointer<cpBody> b,
  cpVect anchorA,
  cpVect anchorB,
);

@ffi.Native<cpVect Function(ffi.Pointer<cpConstraint>)>()
external cpVect cp_pivot_joint_get_anchor_a(
  ffi.Pointer<cpConstraint> constraint,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpConstraint>, cpVect)>()
external void cp_pivot_joint_set_anchor_a(
  ffi.Pointer<cpConstraint> constraint,
  cpVect anchorA,
);

@ffi.Native<cpVect Function(ffi.Pointer<cpConstraint>)>()
external cpVect cp_pivot_joint_get_anchor_b(
  ffi.Pointer<cpConstraint> constraint,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpConstraint>, cpVect)>()
external void cp_pivot_joint_set_anchor_b(
  ffi.Pointer<cpConstraint> constraint,
  cpVect anchorB,
);

/// Groove joint
@ffi.Native<ffi.Pointer<cpConstraint> Function(ffi.Pointer<cpBody>, ffi.Pointer<cpBody>, cpVect, cpVect, cpVect)>()
external ffi.Pointer<cpConstraint> cp_groove_joint_new(
  ffi.Pointer<cpBody> a,
  ffi.Pointer<cpBody> b,
  cpVect groove_a,
  cpVect groove_b,
  cpVect anchorB,
);

@ffi.Native<cpVect Function(ffi.Pointer<cpConstraint>)>()
external cpVect cp_groove_joint_get_groove_a(
  ffi.Pointer<cpConstraint> constraint,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpConstraint>, cpVect)>()
external void cp_groove_joint_set_groove_a(
  ffi.Pointer<cpConstraint> constraint,
  cpVect grooveA,
);

@ffi.Native<cpVect Function(ffi.Pointer<cpConstraint>)>()
external cpVect cp_groove_joint_get_groove_b(
  ffi.Pointer<cpConstraint> constraint,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpConstraint>, cpVect)>()
external void cp_groove_joint_set_groove_b(
  ffi.Pointer<cpConstraint> constraint,
  cpVect grooveB,
);

@ffi.Native<cpVect Function(ffi.Pointer<cpConstraint>)>()
external cpVect cp_groove_joint_get_anchor_b(
  ffi.Pointer<cpConstraint> constraint,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpConstraint>, cpVect)>()
external void cp_groove_joint_set_anchor_b(
  ffi.Pointer<cpConstraint> constraint,
  cpVect anchorB,
);

/// Damped spring
@ffi.Native<
  ffi.Pointer<cpConstraint> Function(
    ffi.Pointer<cpBody>,
    ffi.Pointer<cpBody>,
    cpVect,
    cpVect,
    cpFloat,
    cpFloat,
    cpFloat,
  )
>()
external ffi.Pointer<cpConstraint> cp_damped_spring_new(
  ffi.Pointer<cpBody> a,
  ffi.Pointer<cpBody> b,
  cpVect anchorA,
  cpVect anchorB,
  double restLength,
  double stiffness,
  double damping,
);

@ffi.Native<cpVect Function(ffi.Pointer<cpConstraint>)>()
external cpVect cp_damped_spring_get_anchor_a(
  ffi.Pointer<cpConstraint> constraint,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpConstraint>, cpVect)>()
external void cp_damped_spring_set_anchor_a(
  ffi.Pointer<cpConstraint> constraint,
  cpVect anchorA,
);

@ffi.Native<cpVect Function(ffi.Pointer<cpConstraint>)>()
external cpVect cp_damped_spring_get_anchor_b(
  ffi.Pointer<cpConstraint> constraint,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpConstraint>, cpVect)>()
external void cp_damped_spring_set_anchor_b(
  ffi.Pointer<cpConstraint> constraint,
  cpVect anchorB,
);

@ffi.Native<cpFloat Function(ffi.Pointer<cpConstraint>)>()
external double cp_damped_spring_get_rest_length(
  ffi.Pointer<cpConstraint> constraint,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpConstraint>, cpFloat)>()
external void cp_damped_spring_set_rest_length(
  ffi.Pointer<cpConstraint> constraint,
  double restLength,
);

@ffi.Native<cpFloat Function(ffi.Pointer<cpConstraint>)>()
external double cp_damped_spring_get_stiffness(
  ffi.Pointer<cpConstraint> constraint,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpConstraint>, cpFloat)>()
external void cp_damped_spring_set_stiffness(
  ffi.Pointer<cpConstraint> constraint,
  double stiffness,
);

@ffi.Native<cpFloat Function(ffi.Pointer<cpConstraint>)>()
external double cp_damped_spring_get_damping(
  ffi.Pointer<cpConstraint> constraint,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpConstraint>, cpFloat)>()
external void cp_damped_spring_set_damping(
  ffi.Pointer<cpConstraint> constraint,
  double damping,
);

/// Damped rotary spring
@ffi.Native<ffi.Pointer<cpConstraint> Function(ffi.Pointer<cpBody>, ffi.Pointer<cpBody>, cpFloat, cpFloat, cpFloat)>()
external ffi.Pointer<cpConstraint> cp_damped_rotary_spring_new(
  ffi.Pointer<cpBody> a,
  ffi.Pointer<cpBody> b,
  double restAngle,
  double stiffness,
  double damping,
);

@ffi.Native<cpFloat Function(ffi.Pointer<cpConstraint>)>()
external double cp_damped_rotary_spring_get_rest_angle(
  ffi.Pointer<cpConstraint> constraint,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpConstraint>, cpFloat)>()
external void cp_damped_rotary_spring_set_rest_angle(
  ffi.Pointer<cpConstraint> constraint,
  double restAngle,
);

@ffi.Native<cpFloat Function(ffi.Pointer<cpConstraint>)>()
external double cp_damped_rotary_spring_get_stiffness(
  ffi.Pointer<cpConstraint> constraint,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpConstraint>, cpFloat)>()
external void cp_damped_rotary_spring_set_stiffness(
  ffi.Pointer<cpConstraint> constraint,
  double stiffness,
);

@ffi.Native<cpFloat Function(ffi.Pointer<cpConstraint>)>()
external double cp_damped_rotary_spring_get_damping(
  ffi.Pointer<cpConstraint> constraint,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpConstraint>, cpFloat)>()
external void cp_damped_rotary_spring_set_damping(
  ffi.Pointer<cpConstraint> constraint,
  double damping,
);

/// Rotary limit joint
@ffi.Native<ffi.Pointer<cpConstraint> Function(ffi.Pointer<cpBody>, ffi.Pointer<cpBody>, cpFloat, cpFloat)>()
external ffi.Pointer<cpConstraint> cp_rotary_limit_joint_new(
  ffi.Pointer<cpBody> a,
  ffi.Pointer<cpBody> b,
  double min,
  double max,
);

@ffi.Native<cpFloat Function(ffi.Pointer<cpConstraint>)>()
external double cp_rotary_limit_joint_get_min(
  ffi.Pointer<cpConstraint> constraint,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpConstraint>, cpFloat)>()
external void cp_rotary_limit_joint_set_min(
  ffi.Pointer<cpConstraint> constraint,
  double min,
);

@ffi.Native<cpFloat Function(ffi.Pointer<cpConstraint>)>()
external double cp_rotary_limit_joint_get_max(
  ffi.Pointer<cpConstraint> constraint,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpConstraint>, cpFloat)>()
external void cp_rotary_limit_joint_set_max(
  ffi.Pointer<cpConstraint> constraint,
  double max,
);

/// Ratchet joint
@ffi.Native<ffi.Pointer<cpConstraint> Function(ffi.Pointer<cpBody>, ffi.Pointer<cpBody>, cpFloat, cpFloat)>()
external ffi.Pointer<cpConstraint> cp_ratchet_joint_new(
  ffi.Pointer<cpBody> a,
  ffi.Pointer<cpBody> b,
  double phase,
  double ratchet,
);

@ffi.Native<cpFloat Function(ffi.Pointer<cpConstraint>)>()
external double cp_ratchet_joint_get_angle(
  ffi.Pointer<cpConstraint> constraint,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpConstraint>, cpFloat)>()
external void cp_ratchet_joint_set_angle(
  ffi.Pointer<cpConstraint> constraint,
  double angle,
);

@ffi.Native<cpFloat Function(ffi.Pointer<cpConstraint>)>()
external double cp_ratchet_joint_get_phase(
  ffi.Pointer<cpConstraint> constraint,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpConstraint>, cpFloat)>()
external void cp_ratchet_joint_set_phase(
  ffi.Pointer<cpConstraint> constraint,
  double phase,
);

@ffi.Native<cpFloat Function(ffi.Pointer<cpConstraint>)>()
external double cp_ratchet_joint_get_ratchet(
  ffi.Pointer<cpConstraint> constraint,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpConstraint>, cpFloat)>()
external void cp_ratchet_joint_set_ratchet(
  ffi.Pointer<cpConstraint> constraint,
  double ratchet,
);

/// Gear joint
@ffi.Native<ffi.Pointer<cpConstraint> Function(ffi.Pointer<cpBody>, ffi.Pointer<cpBody>, cpFloat, cpFloat)>()
external ffi.Pointer<cpConstraint> cp_gear_joint_new(
  ffi.Pointer<cpBody> a,
  ffi.Pointer<cpBody> b,
  double phase,
  double ratio,
);

@ffi.Native<cpFloat Function(ffi.Pointer<cpConstraint>)>()
external double cp_gear_joint_get_phase(
  ffi.Pointer<cpConstraint> constraint,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpConstraint>, cpFloat)>()
external void cp_gear_joint_set_phase(
  ffi.Pointer<cpConstraint> constraint,
  double phase,
);

@ffi.Native<cpFloat Function(ffi.Pointer<cpConstraint>)>()
external double cp_gear_joint_get_ratio(
  ffi.Pointer<cpConstraint> constraint,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpConstraint>, cpFloat)>()
external void cp_gear_joint_set_ratio(
  ffi.Pointer<cpConstraint> constraint,
  double ratio,
);

/// Simple motor
@ffi.Native<ffi.Pointer<cpConstraint> Function(ffi.Pointer<cpBody>, ffi.Pointer<cpBody>, cpFloat)>()
external ffi.Pointer<cpConstraint> cp_simple_motor_new(
  ffi.Pointer<cpBody> a,
  ffi.Pointer<cpBody> b,
  double rate,
);

@ffi.Native<cpFloat Function(ffi.Pointer<cpConstraint>)>()
external double cp_simple_motor_get_rate(
  ffi.Pointer<cpConstraint> constraint,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpConstraint>, cpFloat)>()
external void cp_simple_motor_set_rate(
  ffi.Pointer<cpConstraint> constraint,
  double rate,
);

/// Arbiter
@ffi.Native<cpFloat Function(ffi.Pointer<cpArbiter>)>()
external double cp_arbiter_get_restitution(
  ffi.Pointer<cpArbiter> arb,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpArbiter>, cpFloat)>()
external void cp_arbiter_set_restitution(
  ffi.Pointer<cpArbiter> arb,
  double restitution,
);

@ffi.Native<cpFloat Function(ffi.Pointer<cpArbiter>)>()
external double cp_arbiter_get_friction(
  ffi.Pointer<cpArbiter> arb,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpArbiter>, cpFloat)>()
external void cp_arbiter_set_friction(
  ffi.Pointer<cpArbiter> arb,
  double friction,
);

@ffi.Native<cpVect Function(ffi.Pointer<cpArbiter>)>()
external cpVect cp_arbiter_get_surface_velocity(
  ffi.Pointer<cpArbiter> arb,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpArbiter>, cpVect)>()
external void cp_arbiter_set_surface_velocity(
  ffi.Pointer<cpArbiter> arb,
  cpVect vr,
);

@ffi.Native<cpVect Function(ffi.Pointer<cpArbiter>)>()
external cpVect cp_arbiter_total_impulse(
  ffi.Pointer<cpArbiter> arb,
);

@ffi.Native<cpFloat Function(ffi.Pointer<cpArbiter>)>()
external double cp_arbiter_total_ke(
  ffi.Pointer<cpArbiter> arb,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<cpArbiter>)>()
external int cp_arbiter_ignore(
  ffi.Pointer<cpArbiter> arb,
);

@ffi.Native<
  ffi.Void Function(ffi.Pointer<cpArbiter>, ffi.Pointer<ffi.Pointer<cpShape>>, ffi.Pointer<ffi.Pointer<cpShape>>)
>()
external void cp_arbiter_get_shapes(
  ffi.Pointer<cpArbiter> arb,
  ffi.Pointer<ffi.Pointer<cpShape>> a,
  ffi.Pointer<ffi.Pointer<cpShape>> b,
);

@ffi.Native<
  ffi.Void Function(ffi.Pointer<cpArbiter>, ffi.Pointer<ffi.Pointer<cpBody>>, ffi.Pointer<ffi.Pointer<cpBody>>)
>()
external void cp_arbiter_get_bodies(
  ffi.Pointer<cpArbiter> arb,
  ffi.Pointer<ffi.Pointer<cpBody>> a,
  ffi.Pointer<ffi.Pointer<cpBody>> b,
);

@ffi.Native<cpContactPointSet Function(ffi.Pointer<cpArbiter>)>()
external cpContactPointSet cp_arbiter_get_contact_point_set(
  ffi.Pointer<cpArbiter> arb,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<cpArbiter>, ffi.Pointer<cpContactPointSet>)>()
external void cp_arbiter_set_contact_point_set(
  ffi.Pointer<cpArbiter> arb,
  ffi.Pointer<cpContactPointSet> set,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<cpArbiter>)>()
external int cp_arbiter_is_first_contact(
  ffi.Pointer<cpArbiter> arb,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<cpArbiter>)>()
external int cp_arbiter_is_removal(
  ffi.Pointer<cpArbiter> arb,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<cpArbiter>)>()
external int cp_arbiter_get_count(
  ffi.Pointer<cpArbiter> arb,
);

@ffi.Native<cpVect Function(ffi.Pointer<cpArbiter>)>()
external cpVect cp_arbiter_get_normal(
  ffi.Pointer<cpArbiter> arb,
);

@ffi.Native<cpVect Function(ffi.Pointer<cpArbiter>, ffi.Int)>()
external cpVect cp_arbiter_get_point_a(
  ffi.Pointer<cpArbiter> arb,
  int i,
);

@ffi.Native<cpVect Function(ffi.Pointer<cpArbiter>, ffi.Int)>()
external cpVect cp_arbiter_get_point_b(
  ffi.Pointer<cpArbiter> arb,
  int i,
);

@ffi.Native<cpFloat Function(ffi.Pointer<cpArbiter>, ffi.Int)>()
external double cp_arbiter_get_depth(
  ffi.Pointer<cpArbiter> arb,
  int i,
);

/// Utility functions
@ffi.Native<cpFloat Function(cpFloat, cpFloat, cpFloat, cpVect)>()
external double cp_moment_for_circle(
  double m,
  double r1,
  double r2,
  cpVect offset,
);

@ffi.Native<cpFloat Function(cpFloat, cpFloat)>()
external double cp_area_for_circle(
  double r1,
  double r2,
);

@ffi.Native<cpFloat Function(cpFloat, cpVect, cpVect, cpFloat)>()
external double cp_moment_for_segment(
  double m,
  cpVect a,
  cpVect b,
  double radius,
);

@ffi.Native<cpFloat Function(cpVect, cpVect, cpFloat)>()
external double cp_area_for_segment(
  cpVect a,
  cpVect b,
  double radius,
);

@ffi.Native<cpFloat Function(cpFloat, ffi.Int, ffi.Pointer<cpVect>, cpVect, cpFloat)>()
external double cp_moment_for_poly(
  double m,
  int count,
  ffi.Pointer<cpVect> verts,
  cpVect offset,
  double radius,
);

@ffi.Native<cpFloat Function(ffi.Int, ffi.Pointer<cpVect>, cpFloat)>()
external double cp_area_for_poly(
  int count,
  ffi.Pointer<cpVect> verts,
  double radius,
);

@ffi.Native<cpVect Function(ffi.Int, ffi.Pointer<cpVect>)>()
external cpVect cp_centroid_for_poly(
  int count,
  ffi.Pointer<cpVect> verts,
);

@ffi.Native<cpFloat Function(cpFloat, cpFloat, cpFloat)>()
external double cp_moment_for_box(
  double m,
  double width,
  double height,
);

@ffi.Native<cpFloat Function(cpFloat, cpBB)>()
external double cp_moment_for_box2(
  double m,
  cpBB box,
);

@ffi.Native<ffi.Int Function(ffi.Int, ffi.Pointer<cpVect>, ffi.Pointer<cpVect>, ffi.Pointer<ffi.Int>, cpFloat)>()
external int cp_convex_hull(
  int count,
  ffi.Pointer<cpVect> verts,
  ffi.Pointer<cpVect> result,
  ffi.Pointer<ffi.Int> first,
  double tol,
);

final class cpSpace extends ffi.Opaque {}

/// Chipmunk's floating point type.
/// Can be reconfigured at compile time.
typedef cpFloat = ffi.Double;
typedef DartcpFloat = double;

/// Chipmunk's 2D vector type.
/// @addtogroup cpVect
final class cpVect extends ffi.Struct {
  @cpFloat()
  external double x;

  @cpFloat()
  external double y;
}

final class cpShape extends ffi.Opaque {}

final class cpBody extends ffi.Opaque {}

final class cpConstraint extends ffi.Opaque {}

/// Column major affine transform.
final class cpTransform extends ffi.Struct {
  @cpFloat()
  external double a;

  @cpFloat()
  external double b;

  @cpFloat()
  external double c;

  @cpFloat()
  external double d;

  @cpFloat()
  external double tx;

  @cpFloat()
  external double ty;
}

/// Chipmunk's axis-aligned 2D bounding box type. (left, bottom, right, top)
final class cpBB extends ffi.Struct {
  @cpFloat()
  external double l;

  @cpFloat()
  external double b;

  @cpFloat()
  external double r;

  @cpFloat()
  external double t;
}

/// Type used for cpShape.group.
typedef cpGroup = ffi.UintPtr;
typedef DartcpGroup = int;

/// Type used for cpShapeFilter category and mask.
typedef cpBitmask = ffi.UnsignedInt;
typedef DartcpBitmask = int;

/// Fast collision filtering type that is used to determine if two objects collide before calling collision or query callbacks.
final class cpShapeFilter extends ffi.Struct {
  /// Two objects with the same non-zero group value do not collide.
  /// This is generally used to group objects in a composite object together to disable self collisions.
  @cpGroup()
  external int group;

  /// A bitmask of user definable categories that this object belongs to.
  /// The category/mask combinations of both objects in a collision must agree for a collision to occur.
  @cpBitmask()
  external int categories;

  /// A bitmask of user definable category types that this object object collides with.
  /// The category/mask combinations of both objects in a collision must agree for a collision to occur.
  @cpBitmask()
  external int mask;
}

/// Point query info struct.
final class cpPointQueryInfo extends ffi.Struct {
  /// The nearest shape, NULL if no shape was within range.
  external ffi.Pointer<cpShape> shape;

  /// The closest point on the shape's surface. (in world space coordinates)
  external cpVect point;

  /// The distance to the point. The distance is negative if the point is inside the shape.
  @cpFloat()
  external double distance;

  /// The gradient of the signed distance function.
  /// The value should be similar to info.p/info.d, but accurate even for very small values of info.d.
  external cpVect gradient;
}

/// Segment query info struct.
final class cpSegmentQueryInfo extends ffi.Struct {
  /// The shape that was hit, or NULL if no collision occured.
  external ffi.Pointer<cpShape> shape;

  /// The point of impact.
  external cpVect point;

  /// The normal of the surface hit.
  external cpVect normal;

  /// The normalized distance along the query segment in the range [0, 1].
  @cpFloat()
  external double alpha;
}

/// The array of contact points.
final class UnnamedStruct extends ffi.Struct {
  /// The position of the contact on the surface of each shape.
  external cpVect pointA;

  external cpVect pointB;

  /// Penetration distance of the two shapes. Overlapping means it will be negative.
  /// This value is calculated as cpvdot(cpvsub(point2, point1), normal) and is ignored by cpArbiterSetContactPointSet().
  @cpFloat()
  external double distance;
}

/// A struct that wraps up the important collision data for an arbiter.
final class cpContactPointSet extends ffi.Struct {
  /// The number of contact points in the set.
  @ffi.Int()
  external int count;

  /// The normal of the collision.
  external cpVect normal;

  @ffi.Array.multi([2])
  external ffi.Array<UnnamedStruct> points;
}

final class cpArbiter extends ffi.Opaque {}
